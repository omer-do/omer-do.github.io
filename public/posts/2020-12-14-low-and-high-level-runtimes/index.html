<!doctype html><html lang=en dir=auto data-theme=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Low and High Level Container Runtimes (K8s series - 4) | od-stack</title><meta name=keywords content="kubernetes,containers,infrastructure"><meta name=description content="Hands-on exploration of low-level container runtimes (cgroups, namespaces, runc) and high-level runtimes (Docker, containerd)."><meta name=author content="Omer Dolev"><link rel=canonical href=http://localhost:1313/posts/2020-12-14-low-and-high-level-runtimes/><link crossorigin=anonymous href=/assets/css/stylesheet.61ac92b0e7992b16abbfb57d04b87f47ab6eb38d284d11fe00f817d29ee90bba.css integrity="sha256-YaySsOeZKxarv7V9BLh/R6tus40oTRH+APgX0p7pC7o=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/2020-12-14-low-and-high-level-runtimes/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="http://localhost:1313/posts/2020-12-14-low-and-high-level-runtimes/"><meta property="og:site_name" content="od-stack"><meta property="og:title" content="Low and High Level Container Runtimes (K8s series - 4)"><meta property="og:description" content="Hands-on exploration of low-level container runtimes (cgroups, namespaces, runc) and high-level runtimes (Docker, containerd)."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-12-14T09:50:00+08:00"><meta property="article:modified_time" content="2020-12-14T09:50:00+08:00"><meta property="article:tag" content="Kubernetes"><meta property="article:tag" content="Containers"><meta property="article:tag" content="Infrastructure"><meta property="og:image" content="http://localhost:1313/img/low-and-high-level-runtimes-1.png"><meta property="og:see_also" content="http://localhost:1313/posts/2020-12-16-how-it-all-fits-together/"><meta property="og:see_also" content="http://localhost:1313/posts/2020-12-15-kubernetes-control-plane/"><meta property="og:see_also" content="http://localhost:1313/posts/2020-12-11-container-runtimes/"><meta property="og:see_also" content="http://localhost:1313/posts/2020-12-11-containers/"><meta property="og:see_also" content="http://localhost:1313/posts/2020-12-11-hello-kubernetes/"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/img/low-and-high-level-runtimes-1.png"><meta name=twitter:title content="Low and High Level Container Runtimes (K8s series - 4)"><meta name=twitter:description content="Hands-on exploration of low-level container runtimes (cgroups, namespaces, runc) and high-level runtimes (Docker, containerd)."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"Low and High Level Container Runtimes (K8s series - 4)","item":"http://localhost:1313/posts/2020-12-14-low-and-high-level-runtimes/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Low and High Level Container Runtimes (K8s series - 4)","name":"Low and High Level Container Runtimes (K8s series - 4)","description":"Hands-on exploration of low-level container runtimes (cgroups, namespaces, runc) and high-level runtimes (Docker, containerd).","keywords":["kubernetes","containers","infrastructure"],"articleBody":"Let’s have a short dive into the world of container runtimes, talking about low-level and high-level runtimes (which from now will be referred to as low-level runtimes and high-level runtimes).\nAs mentioned in the previous post, conatiners (in Linux of course) are implemented by Linux namespaces and cgroups. Namespaces help you virtualize the environment while cgroups helps you limit resources consumed by a process. The main responsibility of the low-level runtimes is the creation and configuration of such namespaces and cgroups for containers, and then execution inside those namespaces and cgroups (this is the core functionality of the low-level runtimes, which usually implement more features).\nLet’s Go Low :) NOTE: Based on Ian Lewis post\nI am working on Ubuntu, so to control cgroups you need to run the following (all the cg* commands will probably require sudo):\n# install cgroups control commands sudo apt-get install libcgroup-tools bc We will use a simple container FS as our base FS for our container:\n# creating a sample container and exporting it's FS to a tmp dir CID=$(docker create busybox) ROOTFS=$(mktemp -d) docker export $CID | tar -xf - -C $ROOTFS We will now create cgroups and limit resources for the container:\n# creating cgroups - cpu and memory UUID=$(uuidgen) cgcreate -g cpu,memory:$UUID # configuring memory limit to 100000000 bytes (100MB) cgset -r memory.limit_in_bytes=100000000 $UUID # configuring cpu shares to 512 cgset -r cpu.shares=512 $UUID # we will use the cfs mechanism here (will be explained in a seperate post) cgset -r cpu.cfs_period_us=1000000 $UUID cgset -r cpu.cfs_quota_us=2000000 $UUID OK! We create our container sandbox! Lets execute a command in the container:\n$ cgexec -g cpu,memory:$UUID \\ \u003e unshare -uinpUrf --mount-proc \\ \u003e sh -c \"/bin/hostname $UUID \u0026\u0026 chroot $ROOTFS /bin/sh\" / # echo \"Hello from in a container\" Hello from in a container / # exit The unshare command is used to execute a process in different namespaces Now to clean up, let’s delete our cgroups and tmp dir:\ncgdelete -r -g cpu,memory:$UUID rm -r $ROOTFS One of the most common low-level container runtimes is runc (which by the way, is written in GoLang).\nrunc implements the OCI runtime spec, so for running a container with runc you need a root FS for the container, and a config.json file.\nLet’s run a container with runc:\n# install *runc* in case it's not installed sudo apt-get install runc # create root dir for the container and export a sample FS mkdir rootfs docker export $(docker create busybox) | tar -xf - -C rootfs Now let’s create this config.json file:\n# the following will create a config.json in your current dir runc spec # check the file out cat config.json { \"ociVersion\": \"1.0.0\", \"process\": { \"terminal\": true, \"user\": { \"uid\": 0, \"gid\": 0 }, \"args\": [ ... runc, by default, runs an sh command in a container with root FS at ./rootfs which just so happens to be our current setup :)\nSo we can just use runc:\n# run the container with config.json and ./rootfs which are in our current dir sudo runc run mylovelycontainerid / # echo what a nice container what a nice container / # There are also other container runtimes you can use such as lmctfy and rkt, but for now let’s continue on.\nFun Fact: In addition, there’s systemd-nspawn which enables runnning a command or even an OS in a light-weight namespace container, it resembles the chroot command (which changes your root dir) from a user POV, but actually, it fully virtualizes the FS as well as the hostname, process tree and various IPC subsystems.\nGetting Back Up High-level container runtime functionality is not really about running the container, it is more about the format and management of images, then passing it over to the low-level runtime to actually run the container. Usually these runtimes will provide a daemon layer, or an API to perform those image and container management actions. Since low-level runtimes are more concerned with the container itself, there are also high-level runtimes features that concern a collection of containers (for example, if I want a group of containers to share a network namespace).\nDocker is one of the most common high-level container runtime which originally was developed as a monolith (both low and high level functionalities) client-server oriented daemon (dockerd and docker client) that provides image management, container management and execution along with an API.\nThose pieces of high and low level functionalities were divided into separate projects: runc (low-level) and containerd(high-level).\ndockerd provides features such as building images, and dockerd uses docker-containerd to provide features such as image management and running containers. For instance, Docker’s build step is actually just some logic that interprets a Dockerfile, runs the necessary commands in a container using containerd, and saves the resulting container file system as an image.\ncontainerd architecture implies that it provides a gRPC API to be wrapped by higher layers, giving them image pull and push, management of storage, network interfaces, primitives and namespaces management, and as expected, using runc as the runtime.\ncontainerd has a client cli called containerd-ctr (the command itself is ctr) usually used for debugging and development.\nAnother component people sometimes miss is container-shim. Which helps solving the daemon-ed containers problem. By daemon-ed container problem, I mean, that when dockerd is running a container, the container is now a child process of dockerd, so dockerd has to keep running for the container to keep running. What if I want to upgrade Docker (and inheritingly dockerd)? Also, how do I get the exit code of the container? What are the file descriptors (stdin, stdout and stderr) of the container?\nFor that container-shim exists. When runtimes start the container, containerd-shim allows runc to exit because it’s there to be the parent of the container when runc exits. It keeps the file descriptors open in case containerd or dockerd die for some reason. Also it allow the container exit code to be reported back to a higher level tool (Docker for example) without it having to be the parent of the container and wait for it to exit.\nSo let’s see it in practice ps fxa | grep docker -A 3 2500 ? Ssl 0:27 /usr/bin/dockerd -H unix:///var/run/docker.sock 2556 ? Ssl 0:18 \\_ docker-containerd -l unix:///var/run/docker/libcontainerd/docker-containerd.sock ... Now let’s try to run a simple container:\ndocker run -d alpine sleep 60 ps fxa | grep dockerd -A 3 2500 ? Ssl 0:27 /usr/bin/dockerd -H unix:///var/run/docker.sock 2556 ? Ssl 0:18 \\_ docker-containerd -l unix:///var/run/docker/libcontainerd/docker-containerd.sock 8777 ? Sl 0:00 \\_ docker-containerd-shim 3da7... /var/run/docker/libcontainerd/3da7.. docker-runc 8745 ? Ss 0:00 \\_ sleep 60 ... So the “chain of command” is:\ndockerd –\u003e containerd –\u003e containerd-shim –\u003e “sleep 60” (desired process in the container).\nrunc is not in the chain, cause it exited after starting the container :) ","wordCount":"1131","inLanguage":"en","image":"http://localhost:1313/img/low-and-high-level-runtimes-1.png","datePublished":"2020-12-14T09:50:00+08:00","dateModified":"2020-12-14T09:50:00+08:00","author":{"@type":"Person","name":"Omer Dolev"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/2020-12-14-low-and-high-level-runtimes/"},"publisher":{"@type":"Organization","name":"od-stack","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="od-stack (Alt + H)">od-stack</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/ title=Home><span>Home</span></a></li><li><a href=http://localhost:1313/about/ title=About><span>About</span></a></li><li><a href=http://localhost:1313/archives/ title=Archive><span>Archive</span></a></li><li><a href=http://localhost:1313/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Low and High Level Container Runtimes (K8s series - 4)</h1><div class=post-meta><span title='2020-12-14 09:50:00 +0800 +0800'>December 14, 2020</span>&nbsp;·&nbsp;<span>6 min</span>&nbsp;·&nbsp;<span>Omer Dolev</span></div></header><figure class=entry-cover><img loading=eager src=http://localhost:1313/img/low-and-high-level-runtimes-1.png alt="Low and High Level Container Runtimes"></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#lets-go-low- aria-label="Let&rsquo;s Go Low :)">Let&rsquo;s Go Low :)</a></li><li><a href=#getting-back-up aria-label="Getting Back Up">Getting Back Up</a><ul><li><a href=#so-lets-see-it-in-practice aria-label="So let&rsquo;s see it in practice">So let&rsquo;s see it in practice</a></li></ul></li></ul></div></details></div><div class=post-content><p>Let&rsquo;s have a short dive into the world of container runtimes, talking about low-level and high-level runtimes (which from now will be referred to
as low-level runtimes and high-level runtimes).</p><p>As mentioned in the previous post, conatiners (in Linux of course) are implemented by Linux namespaces and cgroups. Namespaces help you virtualize
the environment while cgroups helps you limit resources consumed by a process. The main responsibility of the low-level runtimes is the creation and
configuration of such namespaces and cgroups for containers, and then execution inside those namespaces and cgroups (this is the core functionality
of the low-level runtimes, which usually implement more features).</p><h1 id=lets-go-low->Let&rsquo;s Go Low :)<a hidden class=anchor aria-hidden=true href=#lets-go-low->#</a></h1><p><strong><em>NOTE:</em></strong> Based on Ian Lewis <a href=https://www.ianlewis.org/en/container-runtimes-part-2-anatomy-low-level-contai target=_blank rel="noopener noreferrer">post</a></p><p>I am working on Ubuntu, so to control cgroups you need to run the following (all the cg* commands will probably require sudo):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># install cgroups control commands</span>
</span></span><span style=display:flex><span>sudo apt-get install libcgroup-tools bc
</span></span></code></pre></div><p>We will use a simple container FS as our base FS for our container:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># creating a sample container and exporting it&#39;s FS to a tmp dir</span>
</span></span><span style=display:flex><span>CID<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>docker create busybox<span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>ROOTFS<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>mktemp -d<span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>docker export $CID | tar -xf - -C $ROOTFS
</span></span></code></pre></div><p>We will now create cgroups and limit resources for the container:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># creating cgroups - cpu and memory</span>
</span></span><span style=display:flex><span>UUID<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>uuidgen<span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>cgcreate -g cpu,memory:$UUID
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># configuring memory limit to 100000000 bytes (100MB)</span>
</span></span><span style=display:flex><span>cgset -r memory.limit_in_bytes<span style=color:#f92672>=</span><span style=color:#ae81ff>100000000</span> $UUID
</span></span><span style=display:flex><span><span style=color:#75715e># configuring cpu shares to 512</span>
</span></span><span style=display:flex><span>cgset -r cpu.shares<span style=color:#f92672>=</span><span style=color:#ae81ff>512</span> $UUID
</span></span><span style=display:flex><span><span style=color:#75715e># we will use the cfs mechanism here (will be explained in a seperate post)</span>
</span></span><span style=display:flex><span>cgset -r cpu.cfs_period_us<span style=color:#f92672>=</span><span style=color:#ae81ff>1000000</span> $UUID
</span></span><span style=display:flex><span>cgset -r cpu.cfs_quota_us<span style=color:#f92672>=</span><span style=color:#ae81ff>2000000</span> $UUID
</span></span></code></pre></div><p>OK! We create our container sandbox! Lets execute a command in the container:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ cgexec -g cpu,memory:$UUID <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>&gt;     unshare -uinpUrf --mount-proc <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>&gt;     sh -c <span style=color:#e6db74>&#34;/bin/hostname </span>$UUID<span style=color:#e6db74> &amp;&amp; chroot </span>$ROOTFS<span style=color:#e6db74> /bin/sh&#34;</span>
</span></span><span style=display:flex><span>/ <span style=color:#75715e># echo &#34;Hello from in a container&#34;</span>
</span></span><span style=display:flex><span>Hello from in a container
</span></span><span style=display:flex><span>/ <span style=color:#75715e># exit</span>
</span></span></code></pre></div><ul><li>The unshare command is used to execute a process in different namespaces</li></ul><p>Now to clean up, let&rsquo;s delete our cgroups and tmp dir:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>cgdelete -r -g cpu,memory:$UUID
</span></span><span style=display:flex><span>rm -r $ROOTFS
</span></span></code></pre></div><p>One of the most common low-level container runtimes is <a href=https://github.com/opencontainers/*runc* target=_blank rel="noopener noreferrer"><em>runc</em></a> (which by the way, is written in GoLang).<br><em>runc</em> implements the OCI runtime spec, so for running a container with <em>runc</em> you need a root FS for the container, and a config.json file.</p><p>Let&rsquo;s run a container with <em>runc</em>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># install *runc* in case it&#39;s not installed</span>
</span></span><span style=display:flex><span>sudo apt-get install runc
</span></span><span style=display:flex><span><span style=color:#75715e># create root dir for the container and export a sample FS</span>
</span></span><span style=display:flex><span>mkdir rootfs
</span></span><span style=display:flex><span>docker export <span style=color:#66d9ef>$(</span>docker create busybox<span style=color:#66d9ef>)</span> | tar -xf - -C rootfs
</span></span></code></pre></div><p>Now let&rsquo;s create this config.json file:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># the following will create a config.json in your current dir</span>
</span></span><span style=display:flex><span>runc spec
</span></span><span style=display:flex><span><span style=color:#75715e># check the file out</span>
</span></span><span style=display:flex><span>cat config.json
</span></span><span style=display:flex><span><span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;ociVersion&#34;</span>: <span style=color:#e6db74>&#34;1.0.0&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;process&#34;</span>: <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;terminal&#34;</span>: true,
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;user&#34;</span>: <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                        <span style=color:#e6db74>&#34;uid&#34;</span>: 0,
</span></span><span style=display:flex><span>                        <span style=color:#e6db74>&#34;gid&#34;</span>: <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>}</span>,
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;args&#34;</span>: <span style=color:#f92672>[</span>
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p><em>runc</em>, by default, runs an sh command in a container with root FS at ./rootfs which just so happens to be our current setup :)<br>So we can just use <em>runc</em>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># run the container with config.json and ./rootfs which are in our current dir</span>
</span></span><span style=display:flex><span>sudo runc run mylovelycontainerid
</span></span><span style=display:flex><span>/ <span style=color:#75715e># echo what a nice container</span>
</span></span><span style=display:flex><span>what a nice container
</span></span><span style=display:flex><span>/ <span style=color:#75715e>#</span>
</span></span></code></pre></div><p>There are also other container runtimes you can use such as lmctfy and rkt, but for now let&rsquo;s continue on.</p><p><strong><em>Fun Fact:</em></strong> In addition, there&rsquo;s <a href=https://wiki.archlinux.org/index.php/Systemd-nspawn target=_blank rel="noopener noreferrer">systemd-nspawn</a> which enables runnning a command or even an OS in a light-weight namespace container, it resembles the chroot command (which changes your root dir) from a user POV, but actually, it fully virtualizes the FS as well as the hostname,
process tree and various IPC subsystems.</p><h1 id=getting-back-up>Getting Back Up<a hidden class=anchor aria-hidden=true href=#getting-back-up>#</a></h1><p>High-level container runtime functionality is not really about running the container, it is more about the format and management of images, then passing it over to the low-level runtime to actually run the container.
Usually these runtimes will provide a daemon layer, or an API to perform those image and container management actions.
Since low-level runtimes are more concerned with the container itself, there are also high-level runtimes features that concern a collection of containers (for example, if I want a group of containers to share a network namespace).</p><p>Docker is one of the most common high-level container runtime which originally was developed as a monolith (both low and high level functionalities) client-server oriented daemon (dockerd and docker client) that provides image management, container management and execution along with an API.<br>Those pieces of high and low level functionalities were divided into separate projects: <em>runc</em> (low-level) and containerd(high-level).</p><p><img alt=Image2 loading=lazy src=/img/low-and-high-level-runtimes-2.png></p><p><em>dockerd</em> provides features such as building images, and <em>dockerd</em> uses <em>docker-containerd</em> to provide features such as image management and running containers. For instance, Docker&rsquo;s build step is actually just some logic that interprets a Dockerfile, runs the necessary commands in a container using <em>containerd</em>, and saves the resulting container file system as an image.</p><p><em>containerd</em> architecture implies that it provides a gRPC API to be wrapped by higher layers, giving them image pull and push, management of storage, network interfaces, primitives and namespaces management, and as expected, using <em>runc</em> as the runtime.</p><p><img alt=Image3 loading=lazy src=/img/low-and-high-level-runtimes-3.png></p><p><em>containerd</em> has a client cli called containerd-ctr (the command itself is <em>ctr</em>) usually used for debugging and development.</p><p>Another component people sometimes miss is <em>container-shim</em>. Which helps solving the daemon-ed containers problem. By daemon-ed container problem, I mean, that when <em>dockerd</em> is running a container, the container is now a child process of <em>dockerd</em>, so <em>dockerd</em> has to keep running for the container to keep running. What if I want to upgrade Docker (and inheritingly <em>dockerd</em>)? Also, how do I get the exit code of the container? What are the file descriptors (stdin, stdout and stderr) of the container?</p><p>For that <em>container-shim</em> exists. When runtimes start the container, <em>containerd-shim</em> allows <em>runc</em> to exit because it&rsquo;s there to be the parent of the container when <em>runc</em> exits. It keeps the file descriptors open in case containerd or dockerd die for some reason. Also it allow the container exit code to be reported back to a higher level tool (Docker for example) without it having to be the parent of the container and wait for it to exit.</p><h2 id=so-lets-see-it-in-practice>So let&rsquo;s see it in practice<a hidden class=anchor aria-hidden=true href=#so-lets-see-it-in-practice>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>ps fxa | grep docker -A <span style=color:#ae81ff>3</span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>2500</span> ?        Ssl    0:27 /usr/bin/dockerd -H unix:///var/run/docker.sock
</span></span><span style=display:flex><span><span style=color:#ae81ff>2556</span> ?        Ssl    0:18  <span style=color:#ae81ff>\_</span> docker-containerd -l unix:///var/run/docker/libcontainerd/docker-containerd.sock
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>Now let&rsquo;s try to run a simple container:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>docker run -d alpine sleep <span style=color:#ae81ff>60</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ps fxa | grep dockerd -A <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>2500</span> ?        Ssl    0:27 /usr/bin/dockerd -H unix:///var/run/docker.sock
</span></span><span style=display:flex><span><span style=color:#ae81ff>2556</span> ?        Ssl    0:18  <span style=color:#ae81ff>\_</span> docker-containerd -l unix:///var/run/docker/libcontainerd/docker-containerd.sock
</span></span><span style=display:flex><span><span style=color:#ae81ff>8777</span> ?        Sl     0:00      <span style=color:#ae81ff>\_</span> docker-containerd-shim 3da7... /var/run/docker/libcontainerd/3da7.. docker-runc  
</span></span><span style=display:flex><span><span style=color:#ae81ff>8745</span> ?        Ss     0:00          <span style=color:#ae81ff>\_</span> sleep <span style=color:#ae81ff>60</span>  
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>So the &ldquo;chain of command&rdquo; is:</p><p>dockerd &ndash;> containerd &ndash;> containerd-shim &ndash;> &ldquo;sleep 60&rdquo; (desired process in the container).</p><ul><li><em>runc</em> is not in the chain, cause it exited after starting the container :)</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/kubernetes/>Kubernetes</a></li><li><a href=http://localhost:1313/tags/containers/>Containers</a></li><li><a href=http://localhost:1313/tags/infrastructure/>Infrastructure</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/2020-12-15-kubernetes-control-plane/><span class=title>« Prev</span><br><span>Kubernetes Control Plane (K8s series - 5)</span>
</a><a class=next href=http://localhost:1313/posts/2020-12-11-container-runtimes/><span class=title>Next »</span><br><span>Container Runtimes (K8s series - 3)</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=http://localhost:1313/>od-stack</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>