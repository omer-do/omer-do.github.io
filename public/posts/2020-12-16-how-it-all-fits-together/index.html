<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Kubernetes - How It Fits Together (K8s series - 6) | od-stack</title><meta name=keywords content="kubernetes,containers,infrastructure"><meta name=description content="How pods leverage Linux namespaces to share environments between containers, plus a look at the Kubelet and Kube-proxy."><meta name=author content="Omer Dolev"><link rel=canonical href=https://omer-do.github.io/posts/2020-12-16-how-it-all-fits-together/><link crossorigin=anonymous href=/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=https://omer-do.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://omer-do.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://omer-do.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://omer-do.github.io/apple-touch-icon.png><link rel=mask-icon href=https://omer-do.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://omer-do.github.io/posts/2020-12-16-how-it-all-fits-together/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://omer-do.github.io/posts/2020-12-16-how-it-all-fits-together/"><meta property="og:site_name" content="od-stack"><meta property="og:title" content="Kubernetes - How It Fits Together (K8s series - 6)"><meta property="og:description" content="How pods leverage Linux namespaces to share environments between containers, plus a look at the Kubelet and Kube-proxy."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-12-16T09:50:00+08:00"><meta property="article:modified_time" content="2020-12-16T09:50:00+08:00"><meta property="article:tag" content="Kubernetes"><meta property="article:tag" content="Containers"><meta property="article:tag" content="Infrastructure"><meta property="og:image" content="https://omer-do.github.io/img/how-it-all-fits-together-1.png"><meta property="og:see_also" content="https://omer-do.github.io/posts/2020-12-15-kubernetes-control-plane/"><meta property="og:see_also" content="https://omer-do.github.io/posts/2020-12-14-low-and-high-level-runtimes/"><meta property="og:see_also" content="https://omer-do.github.io/posts/2020-12-11-container-runtimes/"><meta property="og:see_also" content="https://omer-do.github.io/posts/2020-12-11-containers/"><meta property="og:see_also" content="https://omer-do.github.io/posts/2020-12-11-hello-kubernetes/"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://omer-do.github.io/img/how-it-all-fits-together-1.png"><meta name=twitter:title content="Kubernetes - How It Fits Together (K8s series - 6)"><meta name=twitter:description content="How pods leverage Linux namespaces to share environments between containers, plus a look at the Kubelet and Kube-proxy."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://omer-do.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Kubernetes - How It Fits Together (K8s series - 6)","item":"https://omer-do.github.io/posts/2020-12-16-how-it-all-fits-together/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Kubernetes - How It Fits Together (K8s series - 6)","name":"Kubernetes - How It Fits Together (K8s series - 6)","description":"How pods leverage Linux namespaces to share environments between containers, plus a look at the Kubelet and Kube-proxy.","keywords":["kubernetes","containers","infrastructure"],"articleBody":"Going to the Roots There is much much more to talk about the control plane, but that’s for more specific posts. Eventually, what we want to do in K8s is actually running workloads in the form of Pods.\nWhat’s a Pod? It’s components? You can read about it from a high-level perspective in the official documentation.\nRewinding back to the containers post, we remember that Linux containers are not really “containers” they are normal processes, executed using 2 features of the Linux Kernel: Namespaces and Control Groups (cgroups).\nPod is actually taking these namespaces and cgroups and leveraging them to make some cool stuff with “containers”. Normally, people see pods like standalone boxes.\nBut there are cool things we can do with namespaces, and they have quite a flexible functionality.\nLet’s create an nginx container and a ghost container in the same namespaces so they are able to talk to each other:\n# conf file for the nginx cat \u003c\u003e nginx.conf error_log stderr; events { worker_connections 1024; } http { access_log /dev/stdout combined; server { listen 80 default_server; server_name example.com www.example.com; location / { proxy_pass http://127.0.0.1:2368; } } } EOF # let's create the nginx container # in the case of the IPC namespace we need to run the first container with shareable IPC mode docker run -d --ipc=\"shareable\" --name nginx -v \"$(pwd)\"/nginx.conf:/etc/nginx/nginx.conf -p 8080:80 nginx # now let's create the ghost container # notice, we are sharing network, IPC, and PID namespaces with the nginx # we can share more namespaces or less namespaces as we like # but for the sake of the example lets share these 3 docker run -d --name ghost --net=container:nginx --ipc=container:nginx --pid=container:nginx ghost After running these commands you can go visit http://localhost:8080/ and see the ghost page behind the Nginx we created.\nBut let’s break down what we have just done.\nThe Nginx is a container, living in its own network namespace. So 127.0.0.1 is the loopback address in the network namespace of the container. Nginx is configured to listen to port 80, and the config says that when we get a request we forward it to http://127.0.0.1:2368, so we actually forward it to a different port (the ghost port).\nThen we ran the ghost container and put it in the same net, PID and IPC namespaces as the Nginx container (I shared 3 namespaces even though just sharing the network one would work).\nNOTE: In this example, even though sharing only the network namespace would work (try it yourself), sharing other namespaces (like PID, IPC, etc…) can be very useful for use-cases that require a certain level of IPC (inter-process communication) or data sharing.\nSo now that the containers are in the same net namespace, the 127.0.0.1 of the Nginx, is actually the 127.0.0.1 of the ghost as well. That’s why this forwarding works.\nAfter sharing all the namespaces it would look something more like this:\nSo pods are almost like that, they combine namespaces with multiple processes. When K8s starts up a pod it’s a bit more complicated as K8s uses CNI (container network interface, which we will talk about) and not docker networking, but the idea of sharing the environment (network, volumes - mounts, IPC - signals for example, processes, hostname…) is the same.\nA pod would look closer to something like this:\nNOTE: For those who know K8s already the cgroup there is why you can configure resources per container in the pod spec.\nOne very good use-case for more than one container in a pod is service meshes for example. Istio (one of the most famous service meshes) usually implemented using what’s called a side-car container. Meaning that it “injects” another container to the pod, that runs along with the application pod and has a view into what’s going on in the pods environment. The sidecar also acts as a gateway having every packet in and out of the pod go through it, letting it extract lots of data, while enabling smart and granular enforcement of net policies.\nThe Kubelet and Kube-proxy The only piece of the puzzle left, is what’s going on the K8s Nodes. The nodes are servers that actually run the containers and the components running there are the Kubelet and the Kube-proxy.\nYou might call them the K8s field agents :)\nThese are the pieces of K8s that do the field work.\nSpecifically, the Kubelet is the component that on first startup registers the node into the cluster, interacts with the container runtime installed on the K8s node to run the pods, as well as reporting the status of the node and the pods running on it back to ETCD.\nThe Kube-proxy, as its name implies, is more related to the network side, specifically to the K8s services (we will talk about that).\nThe CNI (the implementation for network in K8s) is usually a pod or a service that runs on the node (not included in Kubelet or Kube-proxy), which configures the overlay network.\nFun Fact: If you run docker ps on a K8s node, you might notice that there are more containers than you think. In particular, you will have an additional container for each pod whose name is k8s_POD… and it’s command is /pause. This container has a few functionalities and it’ll be discussed in a future post.\nHere is a nice chart showing an overall view of kubernetes (image is link to K8s Docs page):\n","wordCount":"904","inLanguage":"en","image":"https://omer-do.github.io/img/how-it-all-fits-together-1.png","datePublished":"2020-12-16T09:50:00+08:00","dateModified":"2020-12-16T09:50:00+08:00","author":{"@type":"Person","name":"Omer Dolev"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://omer-do.github.io/posts/2020-12-16-how-it-all-fits-together/"},"publisher":{"@type":"Organization","name":"od-stack","logo":{"@type":"ImageObject","url":"https://omer-do.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://omer-do.github.io/ accesskey=h title="od-stack (Alt + H)">od-stack</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://omer-do.github.io/ title=Home><span>Home</span></a></li><li><a href=https://omer-do.github.io/about/ title=About><span>About</span></a></li><li><a href=https://omer-do.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://omer-do.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://omer-do.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://omer-do.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Kubernetes - How It Fits Together (K8s series - 6)</h1><div class=post-meta><span title='2020-12-16 09:50:00 +0800 +0800'>December 16, 2020</span>&nbsp;·&nbsp;<span>5 min</span>&nbsp;·&nbsp;<span>Omer Dolev</span></div></header><figure class=entry-cover><img loading=eager src=https://omer-do.github.io/img/how-it-all-fits-together-1.png alt="Kubernetes Architecture Overview"></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#going-to-the-roots aria-label="Going to the Roots">Going to the Roots</a></li><li><a href=#the-kubelet-and-kube-proxy aria-label="The Kubelet and Kube-proxy">The Kubelet and Kube-proxy</a></li></ul></div></details></div><div class=post-content><h2 id=going-to-the-roots>Going to the Roots<a hidden class=anchor aria-hidden=true href=#going-to-the-roots>#</a></h2><p>There is much much more to talk about the control plane, but that&rsquo;s for more specific posts. Eventually, what we want to do in K8s is actually running workloads in the form of Pods.</p><p>What&rsquo;s a Pod? It&rsquo;s components? You can read about it from a high-level perspective in the <a href=https://kubernetes.io/docs/concepts/workloads/pods/>official documentation</a>.<br>Rewinding back to the containers post, we remember that Linux containers are not really &ldquo;containers&rdquo; they are normal processes, executed using 2 features of the Linux Kernel: Namespaces and Control Groups (cgroups).</p><p>Pod is actually taking these namespaces and cgroups and leveraging them to make some cool stuff with &ldquo;containers&rdquo;. Normally, people see pods like standalone boxes.</p><p><img alt=Image2 loading=lazy src=/img/how-it-all-fits-together-2.png></p><p>But there are cool things we can do with namespaces, and they have quite a flexible functionality.<br>Let&rsquo;s create an nginx container and a ghost container in the same namespaces so they are able to talk to each other:</p><pre tabindex=0><code># conf file for the nginx
cat &lt;&lt;EOF &gt;&gt; nginx.conf

error_log stderr;
events { worker_connections  1024; }
http {
  access_log /dev/stdout combined;
  server {
    listen 80 default_server;
    server_name example.com www.example.com;
    location / {
      proxy_pass http://127.0.0.1:2368;
    }
  }
}
EOF

# let&#39;s create the nginx container
# in the case of the IPC namespace we need to run the first container with shareable IPC mode
docker run -d --ipc=&#34;shareable&#34; --name nginx -v &#34;$(pwd)&#34;/nginx.conf:/etc/nginx/nginx.conf -p 8080:80 nginx

# now let&#39;s create the ghost container
# notice, we are sharing network, IPC, and PID namespaces with the nginx
# we can share more namespaces or less namespaces as we like
# but for the sake of the example lets share these 3
docker run -d --name ghost --net=container:nginx --ipc=container:nginx --pid=container:nginx ghost
</code></pre><p>After running these commands you can go visit http://localhost:8080/ and see the ghost page behind the Nginx we created.<br>But let&rsquo;s break down what we have just done.</p><p>The Nginx is a container, living in its own network namespace. So 127.0.0.1 is the loopback address in the network namespace of the container.
Nginx is configured to listen to port 80, and the config says that when we get a request we forward it to http://127.0.0.1:2368, so we actually forward it to a different port (the ghost port).</p><p>Then we ran the ghost container and put it in the same net, PID and IPC namespaces as the Nginx container (I shared 3 namespaces even though just sharing the network one would work).</p><p><strong><em>NOTE</em></strong>: In this example, even though sharing only the network namespace would work (try it yourself), sharing other namespaces (like PID, IPC, etc&mldr;) can be very useful for use-cases that require a certain level of IPC (inter-process communication) or data sharing.</p><p>So now that the containers are in the same net namespace, the 127.0.0.1 of the Nginx, is actually the 127.0.0.1 of the ghost as well. That&rsquo;s why this forwarding works.<br>After sharing all the namespaces it would look something more like this:</p><p><img alt=Image3 loading=lazy src=/img/how-it-all-fits-together-3.png></p><p>So pods are almost like that, they combine namespaces with multiple processes. When K8s starts up a pod it&rsquo;s a bit more complicated as K8s uses CNI (container network interface, which we will talk about) and not docker networking, but the idea of sharing the environment (network, volumes - mounts, IPC - signals for example, processes, hostname&mldr;) is the same.<br>A pod would look closer to something like this:</p><p><img alt=Image4 loading=lazy src=/img/how-it-all-fits-together-4.png></p><p><strong><em>NOTE</em></strong>: For those who know K8s already the cgroup there is why you can configure resources per container in the pod spec.</p><p>One very good use-case for more than one container in a pod is service meshes for example. <a href=https://istio.io/>Istio</a> (one of the most famous service meshes) usually implemented using what&rsquo;s called a side-car container.
Meaning that it &ldquo;injects&rdquo; another container to the pod, that runs along with the application pod and has a view into what&rsquo;s going on in the pods environment. The sidecar also acts as a gateway having every packet in and out of the pod go through it, letting it extract lots of data, while enabling smart and granular enforcement of net policies.</p><h2 id=the-kubelet-and-kube-proxy>The Kubelet and Kube-proxy<a hidden class=anchor aria-hidden=true href=#the-kubelet-and-kube-proxy>#</a></h2><p>The only piece of the puzzle left, is what&rsquo;s going on the K8s Nodes. The nodes are servers that actually run the containers and the components running there are the Kubelet and the Kube-proxy.<br>You might call them the K8s field agents :)</p><p>These are the pieces of K8s that do the field work.<br>Specifically, the Kubelet is the component that on first startup registers the node into the cluster, interacts with the container runtime installed on the K8s node to run the pods, as well as reporting the status of the node and the pods running on it back to ETCD.<br>The Kube-proxy, as its name implies, is more related to the network side, specifically to the K8s services (we will talk about that).</p><p>The CNI (the implementation for network in K8s) is usually a pod or a service that runs on the node (not included in Kubelet or Kube-proxy), which configures the overlay network.</p><p><strong><em>Fun Fact</em></strong>: If you run <em>docker ps</em> on a K8s node, you might notice that there are more containers than you think. In particular, you will have an additional container for each pod whose name is k8s_POD&mldr; and it&rsquo;s command is /pause. This container has a few functionalities and it&rsquo;ll be discussed in a future post.</p><p>Here is a nice chart showing an overall view of kubernetes (image is link to K8s Docs page):</p><p><img alt=Image5 loading=lazy src=/img/how-it-all-fits-together-5.png></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://omer-do.github.io/tags/kubernetes/>Kubernetes</a></li><li><a href=https://omer-do.github.io/tags/containers/>Containers</a></li><li><a href=https://omer-do.github.io/tags/infrastructure/>Infrastructure</a></li></ul><nav class=paginav><a class=prev href=https://omer-do.github.io/posts/2021-08-31-whats-all-that-cloud-buzz/><span class=title>« Prev</span><br><span>Cloud Services</span>
</a><a class=next href=https://omer-do.github.io/posts/2020-12-15-kubernetes-control-plane/><span class=title>Next »</span><br><span>Kubernetes Control Plane (K8s series - 5)</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://omer-do.github.io/>od-stack</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>