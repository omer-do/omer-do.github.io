<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Container Runtimes (K8s series - 3) | od-stack</title><meta name=keywords content="kubernetes,containers,infrastructure"><meta name=description content="What container runtimes are, the role of OCI standards, and the distinction between high-level and low-level runtimes."><meta name=author content="Omer Dolev"><link rel=canonical href=https://omer-do.github.io/posts/2020-12-11-container-runtimes/><link crossorigin=anonymous href=/assets/css/stylesheet.61ac92b0e7992b16abbfb57d04b87f47ab6eb38d284d11fe00f817d29ee90bba.css integrity="sha256-YaySsOeZKxarv7V9BLh/R6tus40oTRH+APgX0p7pC7o=" rel="preload stylesheet" as=style><link rel=icon href=https://omer-do.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://omer-do.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://omer-do.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://omer-do.github.io/apple-touch-icon.png><link rel=mask-icon href=https://omer-do.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://omer-do.github.io/posts/2020-12-11-container-runtimes/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://omer-do.github.io/posts/2020-12-11-container-runtimes/"><meta property="og:site_name" content="od-stack"><meta property="og:title" content="Container Runtimes (K8s series - 3)"><meta property="og:description" content="What container runtimes are, the role of OCI standards, and the distinction between high-level and low-level runtimes."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-12-11T16:50:00+08:00"><meta property="article:modified_time" content="2020-12-11T16:50:00+08:00"><meta property="article:tag" content="Kubernetes"><meta property="article:tag" content="Containers"><meta property="article:tag" content="Infrastructure"><meta property="og:see_also" content="https://omer-do.github.io/posts/2020-12-16-how-it-all-fits-together/"><meta property="og:see_also" content="https://omer-do.github.io/posts/2020-12-15-kubernetes-control-plane/"><meta property="og:see_also" content="https://omer-do.github.io/posts/2020-12-14-low-and-high-level-runtimes/"><meta property="og:see_also" content="https://omer-do.github.io/posts/2020-12-11-containers/"><meta property="og:see_also" content="https://omer-do.github.io/posts/2020-12-11-hello-kubernetes/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Container Runtimes (K8s series - 3)"><meta name=twitter:description content="What container runtimes are, the role of OCI standards, and the distinction between high-level and low-level runtimes."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://omer-do.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Container Runtimes (K8s series - 3)","item":"https://omer-do.github.io/posts/2020-12-11-container-runtimes/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Container Runtimes (K8s series - 3)","name":"Container Runtimes (K8s series - 3)","description":"What container runtimes are, the role of OCI standards, and the distinction between high-level and low-level runtimes.","keywords":["kubernetes","containers","infrastructure"],"articleBody":"Remember all the things we now know about containers? So every time we want a container we need to create different namespaces and then spawn the process, and when the process exits we need remove them all and do some cleanup? NO…\nThis is what container runtimes are for. As you will see in a moment there are many runtimes, and they are usually called low-level or high-level runtimes. One of the most famous container runtimes is Docker. But since Docker’s release many changes took place in this field on container runtimes.\nNOTE: All the data about container runtimes is based on Ian Lewis’s blog.\nLet’s start some containers! oh… wait… Before we continue we need to understand how a runtime systemizes container creation. In the previous post we saw that containers are actually processes that live in different namespaces than the system ones. But there is one important thing we didn’t mention.\nIf a container is a process, and the process spawns in a different mnt namespace (a different filesystem basically), don’t we need the executable to be in the filesystem that resides in that mnt namespace?\nThe answer is yes. That’s what images are for. A container image is usually a zipped file that contains a filesystem (comprised of different layers) with an executable and all the files required for that executable to run, and some metadata for this image (for instance, maybe this executable should be run with arguments, maybe some environment variables should be set). All this data and the filesystem is called an image.\nSo let’s take Docker as an example. Docker was a single solution for container runtime. It had many functionalities that, at first, were all part of the Docker product, but aren’t really dependent on one another. For example:\nan image format a method for building images management of images management of running containers (including running containers) sharing container images To standardize this, Docker, Google, CoreOS and other leaders in the container industry created the OCI (Open Container Initiative). Docker contributed a standard way of running containers as a library called runc to the OCI (and that’s it, nothing pertaining images or management was standardized by docker for the OCI).\nHigh-level and Low-level Runtimes If we list a few of the common container runtimes, we can see: runc, lxc, lmctfy, docker (containerd), rkt, cri-o. Each one, implements different functionalities in the runtime stack.\nHigh-level runtime is attributed to runtimes that aside from actually running the container are implementing image management, unpacking and image format, as well as API for these operations.\nLow-level runtime is attributed to runtimes that focus on just the part of running the container itself, those that actually use the features of the underlying kernel (namespaces and cgroups in the case of Linux containers).\nThe thing is you can’t really divide runtimes to high-level ones and low-level ones, since there are runtimes that implement the whole stack of functionality.\nFunc Fact: cri-o and container-d are leaning more to the high-level side, and they both use runc as a low-level container runtime. So if you take a, say, low-level runtime developer perspective, the high-level runtime isn’t really a runtime. But from an SRE or developer POV, this is the interface to the container management, so it kind of “wraps” the low-level runtime.\n","wordCount":"552","inLanguage":"en","datePublished":"2020-12-11T16:50:00+08:00","dateModified":"2020-12-11T16:50:00+08:00","author":{"@type":"Person","name":"Omer Dolev"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://omer-do.github.io/posts/2020-12-11-container-runtimes/"},"publisher":{"@type":"Organization","name":"od-stack","logo":{"@type":"ImageObject","url":"https://omer-do.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://omer-do.github.io/ accesskey=h title="od-stack (Alt + H)">od-stack</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://omer-do.github.io/ title=Home><span>Home</span></a></li><li><a href=https://omer-do.github.io/about/ title=About><span>About</span></a></li><li><a href=https://omer-do.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://omer-do.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://omer-do.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://omer-do.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Container Runtimes (K8s series - 3)</h1><div class=post-meta><span title='2020-12-11 16:50:00 +0800 +0800'>December 11, 2020</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>Omer Dolev</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#lets-start-some-containers-oh-wait aria-label="Let&rsquo;s start some containers! oh&mldr; wait&mldr;">Let&rsquo;s start some containers! oh&mldr; wait&mldr;</a><ul><li><a href=#high-level-and-low-level-runtimes aria-label="High-level and Low-level Runtimes">High-level and Low-level Runtimes</a></li></ul></li></ul></div></details></div><div class=post-content><p>Remember all the things we now know about containers?
So every time we want a container we need to create different namespaces and then spawn the process, and when the process exits we need remove them all
and do some cleanup? NO&mldr;</p><p>This is what container runtimes are for. As you will see in a moment there are many runtimes, and they are usually called low-level or high-level runtimes.
One of the most famous container runtimes is Docker. But since Docker&rsquo;s release many changes took place in this field on container runtimes.</p><p><strong><em>NOTE:</em></strong> All the data about container runtimes is based on Ian Lewis&rsquo;s <a href=https://www.ianlewis.org/>blog</a>.</p><h2 id=lets-start-some-containers-oh-wait>Let&rsquo;s start some containers! oh&mldr; wait&mldr;<a hidden class=anchor aria-hidden=true href=#lets-start-some-containers-oh-wait>#</a></h2><p>Before we continue we need to understand how a runtime systemizes container creation. In the <a href=https://omerdolev.github.io/posts/containers/>previous post</a>
we saw that containers are actually processes that live in different namespaces than the system ones. But there is one important thing we didn&rsquo;t mention.</p><p>If a container is a process, and the process spawns in a different mnt namespace (a different filesystem basically), don&rsquo;t we need the executable to be in the
filesystem that resides in that mnt namespace?</p><p>The answer is yes. That&rsquo;s what <em><strong>images</strong></em> are for. A container image is usually a zipped file that contains a filesystem (comprised of different layers) with
an executable and all the files required for that executable to run, and some metadata for this image (for instance, maybe this executable should be run with arguments, maybe
some environment variables should be set). All this data and the filesystem is called an image.</p><p>So let&rsquo;s take Docker as an example. Docker was a single solution for container runtime. It had many functionalities that, at first, were all part of the Docker
product, but aren&rsquo;t really dependent on one another. For example:</p><ul><li>an image format</li><li>a method for building images</li><li>management of images</li><li>management of running containers (including running containers)</li><li>sharing container images</li></ul><p>To standardize this, Docker, Google, CoreOS and other leaders in the container industry created the OCI (Open Container Initiative). Docker contributed a standard
way of running containers as a library called <a href=https://github.com/opencontainers/runc>runc</a> to the OCI (and that&rsquo;s it, nothing pertaining images or management was
standardized by docker for the OCI).</p><h3 id=high-level-and-low-level-runtimes>High-level and Low-level Runtimes<a hidden class=anchor aria-hidden=true href=#high-level-and-low-level-runtimes>#</a></h3><p>If we list a few of the common container runtimes, we can see: runc, lxc, lmctfy, docker (containerd), rkt, cri-o.
Each one, implements different functionalities in the runtime stack.</p><p><img alt=runtimes_pic loading=lazy src=/img/runtimes.png title=Title></p><p>High-level runtime is attributed to runtimes that aside from actually running the container are implementing image management, unpacking and image format,
as well as API for these operations.</p><p>Low-level runtime is attributed to runtimes that focus on just the part of running the container itself, those that actually use the features
of the underlying kernel (namespaces and cgroups in the case of Linux containers).</p><p>The thing is you can&rsquo;t really divide runtimes to high-level ones and low-level ones, since there are runtimes that implement the whole stack of functionality.</p><p><strong><em>Func Fact:</em></strong> cri-o and container-d are leaning more to the high-level side, and they both use runc as a low-level container runtime. So if you take a, say,
low-level runtime developer perspective, the high-level runtime isn&rsquo;t really a runtime. But from an SRE or developer POV, this is the interface to the container
management, so it kind of &ldquo;wraps&rdquo; the low-level runtime.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://omer-do.github.io/tags/kubernetes/>Kubernetes</a></li><li><a href=https://omer-do.github.io/tags/containers/>Containers</a></li><li><a href=https://omer-do.github.io/tags/infrastructure/>Infrastructure</a></li></ul><nav class=paginav><a class=prev href=https://omer-do.github.io/posts/2020-12-14-low-and-high-level-runtimes/><span class=title>« Prev</span><br><span>Low and High Level Container Runtimes (K8s series - 4)</span>
</a><a class=next href=https://omer-do.github.io/posts/2020-12-11-containers/><span class=title>Next »</span><br><span>Containers (K8s series - 2)</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://omer-do.github.io/>od-stack</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>