<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Containers (K8s series - 2) | od-stack</title><meta name=keywords content="kubernetes,containers,linux"><meta name=description content="A deep dive into what Linux containers actually are — namespaces, cgroups, and how they differ from virtual machines."><meta name=author content="Omer Dolev"><link rel=canonical href=https://omer-do.github.io/posts/2020-12-11-containers/><link crossorigin=anonymous href=/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=https://omer-do.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://omer-do.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://omer-do.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://omer-do.github.io/apple-touch-icon.png><link rel=mask-icon href=https://omer-do.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://omer-do.github.io/posts/2020-12-11-containers/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://omer-do.github.io/posts/2020-12-11-containers/"><meta property="og:site_name" content="od-stack"><meta property="og:title" content="Containers (K8s series - 2)"><meta property="og:description" content="A deep dive into what Linux containers actually are — namespaces, cgroups, and how they differ from virtual machines."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-12-11T12:40:00+08:00"><meta property="article:modified_time" content="2020-12-11T12:40:00+08:00"><meta property="article:tag" content="Kubernetes"><meta property="article:tag" content="Containers"><meta property="article:tag" content="Linux"><meta property="og:image" content="https://omer-do.github.io/img/containers-1.png"><meta property="og:see_also" content="https://omer-do.github.io/posts/2020-12-16-how-it-all-fits-together/"><meta property="og:see_also" content="https://omer-do.github.io/posts/2020-12-15-kubernetes-control-plane/"><meta property="og:see_also" content="https://omer-do.github.io/posts/2020-12-14-low-and-high-level-runtimes/"><meta property="og:see_also" content="https://omer-do.github.io/posts/2020-12-11-container-runtimes/"><meta property="og:see_also" content="https://omer-do.github.io/posts/2020-12-11-hello-kubernetes/"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://omer-do.github.io/img/containers-1.png"><meta name=twitter:title content="Containers (K8s series - 2)"><meta name=twitter:description content="A deep dive into what Linux containers actually are — namespaces, cgroups, and how they differ from virtual machines."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://omer-do.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Containers (K8s series - 2)","item":"https://omer-do.github.io/posts/2020-12-11-containers/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Containers (K8s series - 2)","name":"Containers (K8s series - 2)","description":"A deep dive into what Linux containers actually are — namespaces, cgroups, and how they differ from virtual machines.","keywords":["kubernetes","containers","linux"],"articleBody":"Containers are awesome. At first they sound quite simple, but they enable many things that weren’t possible before. Here I will explain what are containers in a bit of a deep-dive so you can truly understand what they are.\nContainers are applications that are abstraced from the environment in which they run. This is the high-level explanation, which is of course correct but it’s a bit vague and general. It is noteworthy that this abstraction is very useful for allowing applications to be deployed easily and consistently (that is regardless what machine the container runs on). What’s more interesting is how containers are actually implemented (at least in Linux) and just how different they are from VMs. Understanding how they are implemented in Linux will give you an idea about what they are and will help you understand the whole thing better as we move on to talk about K8s.\nLinux Containers (LXC) The goal of containers is running workload decoupled from the underlying environment. Even though it’s almost totally decoupled there is one thing that ties the container with the underlying machine, the machines kernel.\nSo Linux containers is an operating system virtualization mechanism for running multiple isolated Linux systems (which we call containers) on a host using a single Linux kernel. This is done, using a feature of the Linux kernel called “Namespaces”.\nLinux Namespaces If you’re familier with the term “namespaces” from programming (in GoLang for example it’s called a “package”), it’s a logical seperate area containing objects isolated from other areas in our code.\nIn Linux, a Linux namespace is a logical seperation of operating system resources. In Linux every namespace has a type which determines the type of resources this namespace can contain. For example, a network namespace will contain network interfaces and sockets, a UTS (Unix Timesharing System) namespace contains seperate hostname and domain name, an mnt (or mount) namespace is a set filesystem mounts visible within the namespace. There are other namespaces as well, and we will get to some of them.\nLinux has system namespaces which are the main namespaces that all the processes in the system live in by default, and each process is bound to one namespace of each type. When running containers we actually run a Linux process in namespaces other than the system ones, which means new namespaces for the process are created, and the process is attached to these namespaces.\nLet’s try, for example, playing with the network namespace. Let’s start by viewing the existing ones and creating a new one (you might need sudo for those commands):\n# create new net namespace ip netns add nstest # verify it was created using the following ip netns list Now remember this is a namespace seperated from the host system namespace. We can now create a veth interfaces pair to connect the two namespaces.\n# create v-eth1 and it's peer v-peer1 ip link add v-eth1 type veth peer name v-peer1 # see interfaces here ip link show # put v-peer1 in new network namespace ip link set v-peer1 netns nstest After this, we can set addresses for the interfaces and bring them up:\nip addr add 10.200.1.1/24 dev v-eth1 ip link set v-eth1 up ip netns exec nstest ip addr add 10.200.1.2/24 dev v-peer1 # Notice that running regular ip commands is in the system namespace ip netns exec nstest ip link set v-peer1 up # and to run the ip commands inside a namespace you need to add the ip netns exec nstest ip link set lo up # ip netns exec before the command OK! now we have a new net namespace and an interface up with an address of 10.200.1.2, also we brought the loopback interface up in nstest.\nNow let’s make a route to forward all traffic from nstest to the system namespace i.e. to v-eth1.\nip netns exec nstest ip route add default via 10.200.1.1 # This adds a route in the routing table to be, by default forwarded to v-eth1 We are almost there, but for the internet connection we want to enable forwarding in the system namespace and share internet access between the host and nstest. This is done by enabling forwarding using the iptables interface.\necho 1 \u003e /proc/sys/net/ipv4/ip_forward # by default there's a '0' there disabling this iptables -P FORWARD DROP # setting default policy in the FORWARD chain to DROP iptables -F FORWARD # flushing forward rules iptables -t nat -F # flushing nat rules iptables -t nat -A POSTROUTING -s 10:200.1.0/255.255.255.0 -o eth0 -j MASQUERADE iptables -A FORWARD -i eth0 -o v-eth1 -j ACCEPT # Allowing forwarding between eth0 and v-eth1 iptables -A FORWARD -o eth0 -i v-eth1 -j ACCEPT # both ways Awesome! Now let’s try to see if we have a connection:\nip netns exec nstest ping 8.8.8.8 PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data. 64 bytes from 8.8.8.8: icmp_seq=1 ttl=50 time=48.6ms 64 bytes from 8.8.8.8: icmp_seq=2 ttl=50 time=52.1ms NOTE: This network namespace game was inspired by https://blogs.igalia.com/dpino/2016/04/10/network-namespaces/\nGREAT!\nBack to Containers So we have an example for the net namespace, now a container is actually attached not only to a different net namespace but also to a different pid namespace (seeing a isolated pid tree), mnt namespace (seeing different mounts), uts namespace (seeing different hostname). This collection of namespaces for a container, is called a container sandbox in some places.\nNow you might think, wait… what about resources, as in CPU and memory. Containers are using the system resources as any other process. But we would also like to control how much resources a container uses, for that we have cgroups (Control Groups, which is another Linux kernel feature) which can cap the memory and CPU shares a process can use (I will get into that in the resource management for K8s post).\nNow an interesting question arises:\nCan you run Windows containers on Linux hosts and vice-versa? The short answer is no. But who likes short answers…\nContaines use the host OS kernel (after all it’s just a simple process) so when running a LINUX container it needs a LINUX kernel, and when running a WINDOWS container it requires a WINDOWS kernel. However, you can run a LINUX container on a WINDOWS host since what happens behind the scenes is that Windows runs a Linux VM (read more here).\nSo we spilt it out already… What is the difference between a container and a VM.\nWhen running a VM, you are running a complete operating system, the kernel and user mode processes, meaning you boot it up, it does its checks and tests, it starts all the required processes just like as if you pushed the “on” button of your computer.\nWhen running a container, you create a few namespaces (sometimes the namespaces will be present already), and you just spawn a process in those namespaces, which results in a much lighter, faster operation.\nStill, there might be some cases in which you would like to use VMs of course. Let’s say that your product is a cross-platform application, and you want to test it on all the common OSs and the last 4 versions of each, for that you will need to run different kernels (operating systems) and test your product on them. Containers are not the correct solution for this use-case. Though for Saas use-cases, containers is mainly the way to go.\n","wordCount":"1232","inLanguage":"en","image":"https://omer-do.github.io/img/containers-1.png","datePublished":"2020-12-11T12:40:00+08:00","dateModified":"2020-12-11T12:40:00+08:00","author":{"@type":"Person","name":"Omer Dolev"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://omer-do.github.io/posts/2020-12-11-containers/"},"publisher":{"@type":"Organization","name":"od-stack","logo":{"@type":"ImageObject","url":"https://omer-do.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://omer-do.github.io/ accesskey=h title="od-stack (Alt + H)">od-stack</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://omer-do.github.io/ title=Home><span>Home</span></a></li><li><a href=https://omer-do.github.io/about/ title=About><span>About</span></a></li><li><a href=https://omer-do.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://omer-do.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://omer-do.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://omer-do.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Containers (K8s series - 2)</h1><div class=post-meta><span title='2020-12-11 12:40:00 +0800 +0800'>December 11, 2020</span>&nbsp;·&nbsp;<span>6 min</span>&nbsp;·&nbsp;<span>Omer Dolev</span></div></header><figure class=entry-cover><img loading=eager src=https://omer-do.github.io/img/containers-1.png alt="Linux Containers"></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#linux-containers-lxc aria-label="Linux Containers (LXC)">Linux Containers (LXC)</a><ul><li><a href=#linux-namespaces aria-label="Linux Namespaces">Linux Namespaces</a></li><li><a href=#back-to-containers aria-label="Back to Containers">Back to Containers</a><ul><li><a href=#can-you-run-windows-containers-on-linux-hosts-and-vice-versa aria-label="Can you run Windows containers on Linux hosts and vice-versa?">Can you run Windows containers on Linux hosts and vice-versa?</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><p>Containers are awesome. At first they sound quite simple, but they enable many things that weren&rsquo;t possible before. Here I will explain what are containers in a bit of a deep-dive so you can truly understand what they are.</p><p>Containers are applications that are abstraced from the environment in which they run. This is the high-level explanation, which is of course correct but it&rsquo;s a bit vague and general. It is noteworthy that this abstraction is very useful for allowing applications to be deployed easily and consistently (that is regardless what machine the container runs on). What&rsquo;s more interesting is how containers are actually implemented (at least in Linux) and just how different they are from VMs.
Understanding how they are implemented in Linux will give you an idea about what they are and will help you understand the whole thing better as we move on to talk about K8s.</p><h2 id=linux-containers-lxc>Linux Containers (LXC)<a hidden class=anchor aria-hidden=true href=#linux-containers-lxc>#</a></h2><p>The goal of containers is running workload decoupled from the underlying environment. Even though it&rsquo;s almost totally decoupled there is one thing that ties the container with the underlying machine, the machines <strong>kernel</strong>.</p><p>So Linux containers is an operating system virtualization mechanism for running multiple isolated Linux systems (which we call containers) on a host using a single Linux kernel.
This is done, using a feature of the Linux kernel called &ldquo;Namespaces&rdquo;.</p><h3 id=linux-namespaces>Linux Namespaces<a hidden class=anchor aria-hidden=true href=#linux-namespaces>#</a></h3><p>If you&rsquo;re familier with the term &ldquo;namespaces&rdquo; from programming (in GoLang for example it&rsquo;s called a &ldquo;package&rdquo;), it&rsquo;s a logical seperate area containing objects isolated from other areas in our code.</p><p>In Linux, a Linux namespace is a logical seperation of operating system resources. In Linux every namespace has a type which determines the type of resources this namespace can contain. For example, a network namespace will contain network interfaces and sockets, a UTS (Unix Timesharing System) namespace contains seperate hostname and domain name, an mnt (or mount) namespace is a set filesystem mounts visible within the namespace. There are other namespaces as well, and we will get to some of them.</p><p>Linux has system namespaces which are the main namespaces that all the processes in the system live in by default, and each process is bound to one namespace of each type.
When running containers we actually run a Linux process in namespaces other than the system ones, which means new namespaces for the process are created, and the process is attached to these namespaces.</p><p>Let&rsquo;s try, for example, playing with the network namespace. Let&rsquo;s start by viewing the existing ones and creating a new one (you might need <em>sudo</em> for those commands):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># create new net namespace</span>
</span></span><span style=display:flex><span>ip netns add nstest
</span></span><span style=display:flex><span><span style=color:#75715e># verify it was created using the following</span>
</span></span><span style=display:flex><span>ip netns list
</span></span></code></pre></div><p>Now remember this is a namespace seperated from the host system namespace.
We can now create a veth interfaces pair to connect the two namespaces.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># create v-eth1 and it&#39;s peer v-peer1</span>
</span></span><span style=display:flex><span>ip link add v-eth1 type veth peer name v-peer1
</span></span><span style=display:flex><span><span style=color:#75715e># see interfaces here</span>
</span></span><span style=display:flex><span>ip link show
</span></span><span style=display:flex><span><span style=color:#75715e># put v-peer1 in new network namespace</span>
</span></span><span style=display:flex><span>ip link set v-peer1 netns nstest
</span></span></code></pre></div><p>After this, we can set addresses for the interfaces and bring them up:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>ip addr add 10.200.1.1/24 dev v-eth1
</span></span><span style=display:flex><span>ip link set v-eth1 up
</span></span><span style=display:flex><span>ip netns exec nstest ip addr add 10.200.1.2/24 dev v-peer1      <span style=color:#75715e># Notice that running regular ip commands is in the system namespace</span>
</span></span><span style=display:flex><span>ip netns exec nstest ip link set v-peer1 up                     <span style=color:#75715e># and to run the ip commands inside a namespace you need to add the</span>
</span></span><span style=display:flex><span>ip netns exec nstest ip link set lo up                          <span style=color:#75715e># ip netns exec &lt;ns_name&gt; before the command</span>
</span></span></code></pre></div><p>OK! now we have a new net namespace and an interface up with an address of 10.200.1.2, also we brought the loopback interface up in nstest.</p><p>Now let&rsquo;s make a route to forward all traffic from nstest to the system namespace i.e. to v-eth1.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>ip netns exec nstest ip route add default via 10.200.1.1        <span style=color:#75715e># This adds a route in the routing table to be, by default forwarded to v-eth1</span>
</span></span></code></pre></div><p>We are almost there, but for the internet connection we want to enable forwarding in the system namespace and share internet access between the host and nstest.
This is done by enabling forwarding using the iptables interface.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>echo <span style=color:#ae81ff>1</span> &gt; /proc/sys/net/ipv4/ip_forward                       <span style=color:#75715e># by default there&#39;s a &#39;0&#39; there disabling this</span>
</span></span><span style=display:flex><span>iptables -P FORWARD DROP                                     <span style=color:#75715e># setting default policy in the FORWARD chain to DROP</span>
</span></span><span style=display:flex><span>iptables -F FORWARD                                          <span style=color:#75715e># flushing forward rules</span>
</span></span><span style=display:flex><span>iptables -t nat -F                                           <span style=color:#75715e># flushing nat rules</span>
</span></span><span style=display:flex><span>iptables -t nat -A POSTROUTING -s 10:200.1.0/255.255.255.0 -o eth0 -j MASQUERADE
</span></span><span style=display:flex><span>iptables -A FORWARD -i eth0 -o v-eth1 -j ACCEPT              <span style=color:#75715e># Allowing forwarding between eth0 and v-eth1</span>
</span></span><span style=display:flex><span>iptables -A FORWARD -o eth0 -i v-eth1 -j ACCEPT              <span style=color:#75715e># both ways</span>
</span></span></code></pre></div><p>Awesome! Now let&rsquo;s try to see if we have a connection:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>ip netns exec nstest ping 8.8.8.8
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>PING 8.8.8.8 <span style=color:#f92672>(</span>8.8.8.8<span style=color:#f92672>)</span> 56<span style=color:#f92672>(</span>84<span style=color:#f92672>)</span> bytes of data.
</span></span><span style=display:flex><span><span style=color:#ae81ff>64</span> bytes from 8.8.8.8: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>50</span> time<span style=color:#f92672>=</span>48.6ms
</span></span><span style=display:flex><span><span style=color:#ae81ff>64</span> bytes from 8.8.8.8: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>50</span> time<span style=color:#f92672>=</span>52.1ms
</span></span></code></pre></div><p><strong><em>NOTE:</em></strong> This network namespace game was inspired by <a href=https://blogs.igalia.com/dpino/2016/04/10/network-namespaces/>https://blogs.igalia.com/dpino/2016/04/10/network-namespaces/</a></p><p>GREAT!</p><h3 id=back-to-containers>Back to Containers<a hidden class=anchor aria-hidden=true href=#back-to-containers>#</a></h3><p>So we have an example for the net namespace, now a container is actually attached not only to a different net namespace but also to a different pid namespace (seeing a isolated pid tree), mnt namespace (seeing different mounts), uts namespace (seeing different hostname).
This collection of namespaces for a container, is called a container <em><strong>sandbox</strong></em> in some places.</p><p>Now you might think, wait&mldr; what about resources, as in CPU and memory. Containers are using the system resources as any other process. But we would also like to control how much resources a container uses, for that we have cgroups (Control Groups, which is another Linux kernel feature) which can cap the memory and CPU shares a process can use
(I will get into that in the resource management for K8s post).</p><p>Now an interesting question arises:</p><h4 id=can-you-run-windows-containers-on-linux-hosts-and-vice-versa>Can you run Windows containers on Linux hosts and vice-versa?<a hidden class=anchor aria-hidden=true href=#can-you-run-windows-containers-on-linux-hosts-and-vice-versa>#</a></h4><p>The short answer is no. But who likes short answers&mldr;</p><p>Containes use the host OS kernel (after all it&rsquo;s just a simple process) so when running a <em><strong>LINUX</strong></em> container it needs a <em><strong>LINUX</strong></em> kernel, and when running a <em><strong>WINDOWS</strong></em> container it requires a <em><strong>WINDOWS</strong></em> kernel.
However, you <em><strong>can</strong></em> run a <em><strong>LINUX</strong></em> container on a <em><strong>WINDOWS</strong></em> host since what happens behind the scenes is that Windows runs a Linux VM (read more <a href=https://docs.microsoft.com/en-us/virtualization/windowscontainers/deploy-containers/linux-containers>here</a>).</p><p>So we spilt it out already&mldr; What is the difference between a container and a VM.</p><p>When running a VM, you are running a complete operating system, the kernel and user mode processes, meaning you boot it up, it does its checks and tests, it starts all the required processes just like as if you pushed the &ldquo;on&rdquo; button of your computer.</p><p>When running a container, you create a few namespaces (sometimes the namespaces will be present already), and you just spawn a process in those namespaces, which results in a much lighter, faster operation.</p><p>Still, there might be some cases in which you would like to use VMs of course. Let&rsquo;s say that your product is a cross-platform application, and you want to test it on all the common OSs and the last 4 versions of each, for that you will need to run different kernels (operating systems) and test your product on them. Containers are not the correct solution for this use-case. Though for Saas use-cases, containers is mainly the way to go.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://omer-do.github.io/tags/kubernetes/>Kubernetes</a></li><li><a href=https://omer-do.github.io/tags/containers/>Containers</a></li><li><a href=https://omer-do.github.io/tags/linux/>Linux</a></li></ul><nav class=paginav><a class=prev href=https://omer-do.github.io/posts/2020-12-11-container-runtimes/><span class=title>« Prev</span><br><span>Container Runtimes (K8s series - 3)</span>
</a><a class=next href=https://omer-do.github.io/posts/2020-12-11-hello-kubernetes/><span class=title>Next »</span><br><span>Hello Kubernetes (K8s series - 1)</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://omer-do.github.io/>od-stack</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>